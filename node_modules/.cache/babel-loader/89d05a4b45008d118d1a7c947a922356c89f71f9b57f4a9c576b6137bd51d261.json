{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n  DefaultScope: \"/.default\",\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\"\n  }\n};\nfunction isUuid(text) {\n  return /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/.test(text);\n}\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge = async challengeOptions => {\n  const requestOptions = requestToOptions(challengeOptions.request);\n  const challenge = getChallenge(challengeOptions.response);\n  if (challenge) {\n    const challengeInfo = parseChallenge(challenge);\n    const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n    const tenantId = extractTenantId(challengeInfo);\n    if (!tenantId) {\n      return false;\n    }\n    const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), {\n      tenantId\n    }));\n    if (!accessToken) {\n      return false;\n    }\n    challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);\n    return true;\n  }\n  return false;\n};\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n  const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  const pathSegments = parsedAuthUri.pathname.split(\"/\");\n  const tenantId = pathSegments[1];\n  if (tenantId && isUuid(tenantId)) {\n    return tenantId;\n  }\n  return undefined;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n  if (!challengeInfo.resource_id) {\n    return challengeOptions.scopes;\n  }\n  const challengeScopes = new URL(challengeInfo.resource_id);\n  challengeScopes.pathname = Constants.DefaultScope;\n  let scope = challengeScopes.toString();\n  if (scope === \"https://disk.azure.com/.default\") {\n    // the extra slash is required by the service\n    scope = \"https://disk.azure.com//.default\";\n  }\n  return [scope];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n  const bearerChallenge = challenge.slice(\"Bearer \".length);\n  const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter(x => x);\n  const keyValuePairs = challengeParts.map(keyValue => (([key, value]) => ({\n    [key]: value\n  }))(keyValue.trim().split(\"=\")));\n  // Key-value pairs to plain object:\n  return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout\n    },\n    tracingOptions: request.tracingOptions\n  };\n}","map":{"version":3,"names":["Constants","DefaultScope","HeaderConstants","AUTHORIZATION","isUuid","text","test","authorizeRequestOnTenantChallenge","challengeOptions","requestOptions","requestToOptions","request","challenge","getChallenge","response","challengeInfo","parseChallenge","challengeScopes","buildScopes","tenantId","extractTenantId","accessToken","getAccessToken","Object","assign","headers","set","token","parsedAuthUri","URL","authorization_uri","pathSegments","pathname","split","undefined","resource_id","scopes","scope","toString","get","status","bearerChallenge","slice","length","challengeParts","trim","filter","x","keyValuePairs","map","keyValue","key","value","reduce","a","b","abortSignal","timeout","tracingOptions"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-client\\src\\authorizeRequestOnTenantChallenge.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AuthorizeRequestOnChallengeOptions,\n  PipelineRequest,\n  PipelineResponse,\n} from \"@azure/core-rest-pipeline\";\n\nimport { GetTokenOptions } from \"@azure/core-auth\";\n\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n  DefaultScope: \"/.default\",\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\",\n  },\n};\n\nfunction isUuid(text: string): boolean {\n  return /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/.test(\n    text,\n  );\n}\n\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge: (\n  challengeOptions: AuthorizeRequestOnChallengeOptions,\n) => Promise<boolean> = async (challengeOptions) => {\n  const requestOptions = requestToOptions(challengeOptions.request);\n  const challenge = getChallenge(challengeOptions.response);\n  if (challenge) {\n    const challengeInfo: Challenge = parseChallenge(challenge);\n    const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n    const tenantId = extractTenantId(challengeInfo);\n    if (!tenantId) {\n      return false;\n    }\n    const accessToken = await challengeOptions.getAccessToken(challengeScopes, {\n      ...requestOptions,\n      tenantId,\n    });\n\n    if (!accessToken) {\n      return false;\n    }\n\n    challengeOptions.request.headers.set(\n      Constants.HeaderConstants.AUTHORIZATION,\n      `Bearer ${accessToken.token}`,\n    );\n    return true;\n  }\n  return false;\n};\n\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo: Challenge): string | undefined {\n  const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  const pathSegments = parsedAuthUri.pathname.split(\"/\");\n  const tenantId = pathSegments[1];\n  if (tenantId && isUuid(tenantId)) {\n    return tenantId;\n  }\n  return undefined;\n}\n\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(\n  challengeOptions: AuthorizeRequestOnChallengeOptions,\n  challengeInfo: Challenge,\n): string[] {\n  if (!challengeInfo.resource_id) {\n    return challengeOptions.scopes;\n  }\n\n  const challengeScopes = new URL(challengeInfo.resource_id);\n  challengeScopes.pathname = Constants.DefaultScope;\n  let scope = challengeScopes.toString();\n  if (scope === \"https://disk.azure.com/.default\") {\n    // the extra slash is required by the service\n    scope = \"https://disk.azure.com//.default\";\n  }\n  return [scope];\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * Challenge structure\n */\ninterface Challenge {\n  authorization_uri: string;\n  resource_id?: string;\n}\n\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge: string): Challenge {\n  const bearerChallenge = challenge.slice(\"Bearer \".length);\n  const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter((x) => x);\n  const keyValuePairs = challengeParts.map((keyValue) =>\n    (([key, value]) => ({ [key]: value }))(keyValue.trim().split(\"=\")),\n  );\n  // Key-value pairs to plain object:\n  return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {} as Challenge);\n}\n\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request: PipelineRequest): GetTokenOptions {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout,\n    },\n    tracingOptions: request.tracingOptions,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}