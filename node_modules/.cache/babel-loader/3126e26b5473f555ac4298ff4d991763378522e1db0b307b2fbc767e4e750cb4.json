{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  async sendRequest(request) {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n    try {\n      return await makeRequest(request);\n    } catch (e) {\n      throw getError(e, request);\n    }\n  }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n  const {\n    abortController,\n    abortControllerCleanup\n  } = setupAbortSignal(request);\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const {\n      streaming,\n      body: requestBody\n    } = buildRequestBody(request);\n    const requestInit = Object.assign(Object.assign({\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal\n    }, \"credentials\" in Request.prototype ? {\n      credentials: request.withCredentials ? \"include\" : \"same-origin\"\n    } : {}), \"cache\" in Request.prototype ? {\n      cache: \"no-store\"\n    } : {});\n    // According to https://fetch.spec.whatwg.org/#fetch-method,\n    // init.duplex must be set when body is a ReadableStream object.\n    // currently \"half\" is the only valid value.\n    if (streaming) {\n      requestInit.duplex = \"half\";\n    }\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, requestInit);\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({\n        loadedBytes: request.body.size\n      });\n    }\n    return buildPipelineResponse(response, request, abortControllerCleanup);\n  } catch (e) {\n    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n    throw e;\n  }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {\n  var _a, _b;\n  const headers = buildPipelineHeaders(httpResponse);\n  const response = {\n    request,\n    headers,\n    status: httpResponse.status\n  };\n  const bodyStream = isWebReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, {\n    onProgress: request.onDownloadProgress,\n    onEnd: abortControllerCleanup\n  }) : httpResponse.body;\n  if (\n  // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n  ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n      abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n    response.bodyAsText = await responseStream.text();\n    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();\n  }\n  return response;\n}\nfunction setupAbortSignal(request) {\n  const abortController = new AbortController();\n  // Cleanup function\n  let abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n    abortListener = event => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      var _a;\n      if (abortListener) {\n        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n  return {\n    abortController,\n    abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e, request) {\n  var _a;\n  if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n      request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n  return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n  return responseHeaders;\n}\nfunction buildRequestBody(request) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n  return isWebReadableStream(body) ? {\n    streaming: true,\n    body: buildBodyStream(body, {\n      onProgress: request.onUploadProgress\n    })\n  } : {\n    streaming: false,\n    body\n  };\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, options = {}) {\n  let loadedBytes = 0;\n  const {\n    onProgress,\n    onEnd\n  } = options;\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      },\n      flush() {\n        onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n      }\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        var _a;\n        const {\n          done,\n          value\n        } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n        loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      },\n      cancel(reason) {\n        onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n        return reader.cancel(reason);\n      }\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","isWebReadableStream","isBlob","body","Blob","FetchHttpClient","sendRequest","request","url","URL","isInsecure","protocol","allowInsecureConnection","Error","proxySettings","makeRequest","e","getError","abortController","abortControllerCleanup","setupAbortSignal","headers","buildFetchHeaders","streaming","requestBody","buildRequestBody","requestInit","Object","assign","method","signal","Request","prototype","credentials","withCredentials","cache","duplex","response","fetch","onUploadProgress","loadedBytes","size","buildPipelineResponse","httpResponse","buildPipelineHeaders","status","bodyStream","buildBodyStream","onProgress","onDownloadProgress","onEnd","_a","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","_b","enableBrowserStreams","browserStreamBody","undefined","responseStream","Response","blobBody","blob","bodyAsText","text","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","value","append","responseHeaders","set","readableStream","options","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","flush","reader","getReader","ReadableStream","pull","done","read","close","releaseLock","cancel","reason","createFetchHttpClient","self"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-rest-pipeline\\src\\fetchHttpClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport type {\n  HttpClient,\n  HttpHeaders as PipelineHeaders,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n} from \"./interfaces.js\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body: unknown): body is Blob {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient implements HttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    try {\n      return await makeRequest(request);\n    } catch (e: any) {\n      throw getError(e, request);\n    }\n  }\n}\n\n/**\n * Sends a request\n */\nasync function makeRequest(request: PipelineRequest): Promise<PipelineResponse> {\n  const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const { streaming, body: requestBody } = buildRequestBody(request);\n    const requestInit: RequestInit = {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      // Cloudflare doesn't implement the full Fetch API spec\n      // because of some of it doesn't make sense in the edge.\n      // See https://github.com/cloudflare/workerd/issues/902\n      ...(\"credentials\" in Request.prototype\n        ? { credentials: request.withCredentials ? \"include\" : \"same-origin\" }\n        : {}),\n      ...(\"cache\" in Request.prototype ? { cache: \"no-store\" } : {}),\n    };\n\n    // According to https://fetch.spec.whatwg.org/#fetch-method,\n    // init.duplex must be set when body is a ReadableStream object.\n    // currently \"half\" is the only valid value.\n    if (streaming) {\n      (requestInit as any).duplex = \"half\";\n    }\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, requestInit);\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({ loadedBytes: request.body.size });\n    }\n    return buildPipelineResponse(response, request, abortControllerCleanup);\n  } catch (e) {\n    abortControllerCleanup?.();\n    throw e;\n  }\n}\n\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(\n  httpResponse: Response,\n  request: PipelineRequest,\n  abortControllerCleanup?: () => void,\n): Promise<PipelineResponse> {\n  const headers = buildPipelineHeaders(httpResponse);\n  const response: PipelineResponse = {\n    request,\n    headers,\n    status: httpResponse.status,\n  };\n\n  const bodyStream = isWebReadableStream(httpResponse.body)\n    ? buildBodyStream(httpResponse.body, {\n        onProgress: request.onDownloadProgress,\n        onEnd: abortControllerCleanup,\n      })\n    : httpResponse.body;\n\n  if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||\n    request.streamResponseStatusCodes?.has(response.status)\n  ) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream ?? undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n      abortControllerCleanup?.();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n\n    response.bodyAsText = await responseStream.text();\n    abortControllerCleanup?.();\n  }\n\n  return response;\n}\n\nfunction setupAbortSignal(request: PipelineRequest): {\n  abortController: AbortController;\n  abortControllerCleanup: (() => void) | undefined;\n} {\n  const abortController = new AbortController();\n\n  // Cleanup function\n  let abortControllerCleanup: (() => void) | undefined;\n\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener: ((event: any) => void) | undefined;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n\n    abortListener = (event: Event) => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      if (abortListener) {\n        request.abortSignal?.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return { abortController, abortControllerCleanup };\n}\n\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e: RestError, request: PipelineRequest): RestError {\n  if (e && e?.name === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: e?.code ?? RestError.REQUEST_SEND_ERROR,\n      request,\n    });\n  }\n}\n\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders: PipelineHeaders): Headers {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse: Response): PipelineHeaders {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\ninterface BuildRequestBodyResponse {\n  body:\n    | string\n    | Blob\n    | ReadableStream<Uint8Array>\n    | ArrayBuffer\n    | ArrayBufferView\n    | FormData\n    | null\n    | undefined;\n  streaming: boolean;\n}\n\nfunction buildRequestBody(request: PipelineRequest): BuildRequestBodyResponse {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isWebReadableStream(body)\n    ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }\n    : { streaming: false, body };\n}\n\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(\n  readableStream: ReadableStream<Uint8Array>,\n  options: { onProgress?: (progress: TransferProgressEvent) => void; onEnd?: () => void } = {},\n): ReadableStream<Uint8Array> {\n  let loadedBytes = 0;\n  const { onProgress, onEnd } = options;\n\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === null) {\n            controller.terminate();\n            return;\n          }\n\n          controller.enqueue(chunk);\n          loadedBytes += chunk.length;\n          if (onProgress) {\n            onProgress({ loadedBytes });\n          }\n        },\n        flush() {\n          onEnd?.();\n        },\n      }),\n    );\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        const { done, value } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          onEnd?.();\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n\n        loadedBytes += value?.length ?? 0;\n\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n\n        if (onProgress) {\n          onProgress({ loadedBytes });\n        }\n      },\n      cancel(reason?: string) {\n        onEnd?.();\n        return reader.cancel(reason);\n      },\n    });\n  }\n}\n\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient(): HttpClient {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream: ReadableStream): boolean {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}