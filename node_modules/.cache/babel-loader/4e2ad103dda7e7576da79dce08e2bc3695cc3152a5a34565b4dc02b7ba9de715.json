{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options) {\n  const {\n    namespace,\n    packageName,\n    packageVersion\n  } = options;\n  function startSpan(name, operationOptions, spanOptions) {\n    var _a;\n    const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), {\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext\n    }));\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions = Object.assign({}, operationOptions, {\n      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), {\n        tracingContext\n      })\n    });\n    return {\n      span,\n      updatedOptions\n    };\n  }\n  async function withSpan(name, operationOptions, callback, spanOptions) {\n    const {\n      span,\n      updatedOptions\n    } = startSpan(name, operationOptions, spanOptions);\n    try {\n      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n      span.setStatus({\n        status: \"success\"\n      });\n      return result;\n    } catch (err) {\n      span.setStatus({\n        status: \"error\",\n        error: err\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n  function withContext(context, callback, ...callbackArgs) {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n  function parseTraceparentHeader(traceparentHeader) {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n  function createRequestHeaders(tracingContext) {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders\n  };\n}","map":{"version":3,"names":["getInstrumenter","knownContextKeys","createTracingClient","options","namespace","packageName","packageVersion","startSpan","name","operationOptions","spanOptions","startSpanResult","Object","assign","tracingContext","_a","tracingOptions","span","getValue","setValue","setAttribute","updatedOptions","withSpan","callback","result","withContext","Promise","resolve","setStatus","status","err","error","end","context","callbackArgs","parseTraceparentHeader","traceparentHeader","createRequestHeaders"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-tracing\\src\\tracingClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  OperationTracingOptions,\n  OptionsWithTracingContext,\n  Resolved,\n  TracingClient,\n  TracingClientOptions,\n  TracingContext,\n  TracingSpan,\n  TracingSpanOptions,\n} from \"./interfaces.js\";\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options: TracingClientOptions): TracingClient {\n  const { namespace, packageName, packageVersion } = options;\n\n  function startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(\n    name: string,\n    operationOptions?: Options,\n    spanOptions?: TracingSpanOptions,\n  ): {\n    span: TracingSpan;\n    updatedOptions: OptionsWithTracingContext<Options>;\n  } {\n    const startSpanResult = getInstrumenter().startSpan(name, {\n      ...spanOptions,\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: operationOptions?.tracingOptions?.tracingContext,\n    });\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions: OptionsWithTracingContext<Options> = Object.assign({}, operationOptions, {\n      tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },\n    });\n\n    return {\n      span,\n      updatedOptions,\n    };\n  }\n\n  async function withSpan<\n    Options extends { tracingOptions?: OperationTracingOptions },\n    Callback extends (\n      updatedOptions: Options,\n      span: Omit<TracingSpan, \"end\">,\n    ) => ReturnType<Callback>,\n  >(\n    name: string,\n    operationOptions: Options,\n    callback: Callback,\n    spanOptions?: TracingSpanOptions,\n  ): Promise<Resolved<ReturnType<Callback>>> {\n    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n    try {\n      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () =>\n        Promise.resolve(callback(updatedOptions, span)),\n      );\n      span.setStatus({ status: \"success\" });\n      return result as ReturnType<typeof withSpan>;\n    } catch (err: any) {\n      span.setStatus({ status: \"error\", error: err });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  function withContext<\n    CallbackArgs extends unknown[],\n    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,\n  >(\n    context: TracingContext,\n    callback: Callback,\n    ...callbackArgs: CallbackArgs\n  ): ReturnType<Callback> {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n  function parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n  function createRequestHeaders(tracingContext?: TracingContext): Record<string, string> {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}