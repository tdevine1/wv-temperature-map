{"ast":null,"code":"'use strict';\n\nconst tds = require('tedious');\nconst debug = require('debug')('mssql:tedi');\nconst BaseRequest = require('../base/request');\nconst RequestError = require('../error/request-error');\nconst {\n  IDS,\n  objectHasProperty\n} = require('../utils');\nconst {\n  TYPES,\n  DECLARATIONS,\n  declare,\n  cast\n} = require('../datatypes');\nconst Table = require('../table');\nconst {\n  PARSERS: UDT\n} = require('../udt');\nconst {\n  valueHandler\n} = require('../shared');\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n    case TYPES.Text:\n      return tds.TYPES.Text;\n    case TYPES.Int:\n      return tds.TYPES.Int;\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n    case TYPES.Float:\n      return tds.TYPES.Float;\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n    case TYPES.Real:\n      return tds.TYPES.Real;\n    case TYPES.Money:\n      return tds.TYPES.Money;\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n    case TYPES.Time:\n      return tds.TYPES.Time;\n    case TYPES.Date:\n      return tds.TYPES.Date;\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n    case TYPES.Char:\n      return tds.TYPES.Char;\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n    case TYPES.Image:\n      return tds.TYPES.Image;\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n    default:\n      return type;\n  }\n};\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined;\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n    case tds.TYPES.Text:\n      return TYPES.Text;\n    case tds.TYPES.NText:\n      return TYPES.NText;\n    case tds.TYPES.Int:\n      return TYPES.Int;\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n    case tds.TYPES.Float:\n      return TYPES.Float;\n    case tds.TYPES.Real:\n      return TYPES.Real;\n    case tds.TYPES.Money:\n      return TYPES.Money;\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n    case tds.TYPES.Time:\n      return TYPES.Time;\n    case tds.TYPES.Date:\n      return TYPES.Date;\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n    case tds.TYPES.Image:\n      return TYPES.Image;\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n  }\n};\nconst createColumns = function (metadata, arrayRowMode) {\n  let out = {};\n  if (arrayRowMode) out = [];\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    const column = metadata[index];\n    const outColumn = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n    if (arrayRowMode) {\n      out.push(outColumn);\n    } else {\n      out[column.colName] = outColumn;\n    }\n  }\n  return out;\n};\nconst valueCorrection = function (value, metadata) {\n  const type = getMssqlType(metadata.type);\n  if (valueHandler.has(type)) {\n    return valueHandler.get(type)(value);\n  } else if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n    for (const col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      });\n    }\n    return tvp;\n  } else {\n    return value;\n  }\n};\nclass Request extends BaseRequest {\n  /*\n  Execute specified sql batch.\n  */\n\n  _batch(batch, callback) {\n    this._isBatch = true;\n    this._query(batch, callback);\n  }\n\n  /*\n  Bulk load.\n  */\n\n  _bulk(table, options, callback) {\n    super._bulk(table, options, err => {\n      if (err) return callback(err);\n      try {\n        table._makeBulk();\n      } catch (e) {\n        return callback(new RequestError(e, 'EREQUEST'));\n      }\n      if (!table.name) {\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n      }\n      if (table.name.charAt(0) === '@') {\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n      }\n      const errors = [];\n      const errorHandlers = {};\n      let hasReturned = false;\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              this.parent.release(connection);\n            }\n            hasReturned = true;\n            callback(err);\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err);\n      };\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n      this.parent.acquire(this, (err, connection) => {\n        const callbackWithRelease = (err, ...args) => {\n          try {\n            this.parent.release(connection);\n          } catch (e) {\n            // noop\n          }\n          callback(err, ...args);\n        };\n        if (err) return callbackWithRelease(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'));\n        }\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        };\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n          delete this._cancel;\n          let error;\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n            hasReturned = true;\n            if (this.stream) {\n              callbackWithRelease(null, rowCount);\n            } else {\n              callbackWithRelease(error, rowCount);\n            }\n          }\n        };\n        const bulk = connection.newBulkLoad(table.path, options, done);\n        for (const col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), {\n            nullable: col.nullable,\n            length: col.length,\n            scale: col.scale,\n            precision: col.precision\n          });\n        }\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err);\n            connection.execBulkLoad(bulk, table.rows);\n          });\n          this._setCurrentRequest(req);\n          connection.execSqlBatch(req);\n        } else {\n          connection.execBulkLoad(bulk, table.rows);\n        }\n      });\n    });\n  }\n\n  /*\n  Execute specified sql command.\n  */\n\n  _query(command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const recordsetcolumns = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let batchLastRow = null;\n      let batchHasOutput = false;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              this.parent.release(connection);\n            }\n            hasReturned = true;\n            callback(err);\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err);\n      };\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        };\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        debug('request(%d): query', IDS.get(this), command);\n        const req = new tds.Request(command, err => {\n          // tedious v15 has started using AggregateErrors to wrap multiple errors into single error objects\n          (err !== null && err !== void 0 && err.errors ? err.errors : [err]).forEach((e, i, {\n            length\n          }) => {\n            // to make sure we handle no-sql errors as well\n            if (e && (!errors.length || errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message)) {\n              e = new RequestError(e, 'EREQUEST');\n              if (this.stream) this.emit('error', e);\n              errors.push(e);\n            }\n          });\n\n          // process batch outputs\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0];\n            for (const name in batchLastRow) {\n              const value = batchLastRow[name];\n              if (name !== '___return___') {\n                output[name] = value;\n              }\n            }\n          }\n          delete this._cancel;\n          let error;\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n            this.parent.release(connection);\n            hasReturned = true;\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): completed', IDS.get(this));\n            }\n            if (this.stream) {\n              callback(null, null, output, rowsAffected, recordsetcolumns);\n            } else {\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns);\n            }\n          }\n        });\n        this._setCurrentRequest(req);\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode);\n          isChunkedRecordset = false;\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns);\n              }\n            } else {\n              this.emit('recordset', columns);\n            }\n          }\n          if (this.arrayRowMode) recordsetcolumns.push(columns);\n        });\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount);\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount);\n            }\n          }\n          // this function is called even when select only set variables so we should skip adding a new recordset\n          if (Object.keys(columns).length === 0) return;\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('');\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null;\n                } else {\n                  row = JSON.parse(concatenatedChunks);\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2);\n\n                // we must collect errors even in stream mode\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = concatenatedChunks;\n            }\n            chunksBuffer = null;\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n            });\n            recordsets.push(recordset);\n          }\n          recordset = [];\n          columns = {};\n        };\n        req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n        req.on('done', doneHandler); // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n          if (this.arrayRowMode) {\n            row = [];\n          } else {\n            row = {};\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            if (this.arrayRowMode) {\n              row.push(col.value);\n            } else {\n              const exi = row[col.metadata.colName];\n              if (exi !== undefined) {\n                if (exi instanceof Array) {\n                  exi.push(col.value);\n                } else {\n                  row[col.metadata.colName] = [exi, col.value];\n                }\n              } else {\n                row[col.metadata.colName] = col.value;\n              }\n            }\n          }\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row;\n              } else {\n                this.emit('row', row);\n              }\n            } else {\n              this.emit('row', row);\n            }\n          } else {\n            recordset.push(row);\n          }\n        });\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              try {\n                param.value = getTediousType(param.type).validate(param.value, this.parent.collation);\n              } catch (e) {\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`;\n                const err = new RequestError(e, 'EPARAM');\n                this.parent.release(connection);\n                return callback(err);\n              }\n            }\n            const declarations = [];\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              declarations.push(`@${name} ${declare(param.type, param)}`);\n            }\n            const assigns = [];\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`);\n            }\n            const selects = [];\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n              const param = this.parameters[name];\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`);\n              }\n            }\n            batchHasOutput = selects.length > 0;\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(', ')}` : ''}`;\n          }\n        } else {\n          for (const name in this.parameters) {\n            if (!objectHasProperty(this.parameters, name)) {\n              continue;\n            }\n            const param = this.parameters[name];\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n        }\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req);\n        } catch (error) {\n          handleError(true, connection, error);\n        }\n      });\n    });\n  }\n\n  /*\n  Execute stored procedure with specified parameters.\n  */\n\n  _execute(procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const recordsetcolumns = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let returnValue = 0;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n              this.parent.release(connection);\n            }\n            hasReturned = true;\n            callback(err);\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err);\n      };\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        };\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        if (debug.enabled) {\n          // log stored procedure executions and provided parameters\n          const params = Object.keys(this.parameters).map(k => this.parameters[k]);\n          // cut long string parameters short to keep log somewhat clean\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s;\n          // format parameter names as 'my_parameter [sql.Int]'\n          const logName = param => param.name + ' [sql.' + param.type.name + ']';\n          const logParams = {};\n          params.forEach(p => {\n            logParams[logName(p)] = logValue(p.value);\n          });\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams);\n        }\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n          delete this._cancel;\n          let error;\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n            this.parent.release(connection);\n            hasReturned = true;\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): complete', IDS.get(this));\n            }\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);\n            }\n          }\n        });\n        this._setCurrentRequest(req);\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode);\n          isChunkedRecordset = false;\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n          if (this.stream) this.emit('recordset', columns);\n          if (this.arrayRowMode) recordsetcolumns.push(columns);\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n          if (this.arrayRowMode) {\n            row = [];\n          } else {\n            row = {};\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n            if (this.arrayRowMode) {\n              row.push(col.value);\n            } else {\n              const exi = row[col.metadata.colName];\n              if (exi != null) {\n                if (exi instanceof Array) {\n                  exi.push(col.value);\n                } else {\n                  row[col.metadata.colName] = [exi, col.value];\n                }\n              } else {\n                row[col.metadata.colName] = col.value;\n              }\n            }\n          }\n          if (this.stream) {\n            this.emit('row', row);\n          } else {\n            recordset.push(row);\n          }\n        });\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount);\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount);\n            }\n          }\n\n          // filter empty recordsets when NOCOUNT is OFF\n          if (Object.keys(columns).length === 0) return;\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null;\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''));\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2);\n\n                // we must collect errors even in stream mode\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = chunksBuffer.join('');\n            }\n            chunksBuffer = null;\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n            });\n            recordsets.push(recordset);\n          }\n          recordset = [];\n          columns = {};\n        });\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus;\n        });\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n        for (const name in this.parameters) {\n          if (!objectHasProperty(this.parameters, name)) {\n            continue;\n          }\n          const param = this.parameters[name];\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          }\n        }\n        connection.callProcedure(req);\n      });\n    });\n  }\n  _pause() {\n    super._pause();\n    if (this._currentRequest) {\n      this._currentRequest.pause();\n    }\n  }\n  _resume() {\n    super._resume();\n    if (this._currentRequest) {\n      this._currentRequest.resume();\n    }\n  }\n}\nmodule.exports = Request;","map":{"version":3,"names":["tds","require","debug","BaseRequest","RequestError","IDS","objectHasProperty","TYPES","DECLARATIONS","declare","cast","Table","PARSERS","UDT","valueHandler","JSON_COLUMN_ID","XML_COLUMN_ID","N_TYPES","BitN","DateTimeN","DecimalN","FloatN","IntN","MoneyN","NumericN","getTediousType","type","VarChar","NVarChar","Text","Int","BigInt","TinyInt","SmallInt","Bit","Float","Decimal","Numeric","Real","Money","SmallMoney","Time","Date","DateTime","DateTime2","DateTimeOffset","SmallDateTime","UniqueIdentifier","Xml","Char","NChar","NText","Image","Binary","VarBinary","Geography","Geometry","TVP","Variant","getMssqlType","length","undefined","id","createColumns","metadata","arrayRowMode","out","index","column","outColumn","name","colName","dataLength","scale","precision","nullable","flags","caseSensitive","identity","readOnly","udtInfo","udt","typeName","database","dbname","schema","owningSchema","assembly","assemblyName","push","valueCorrection","value","has","get","parameterCorrection","tvp","columns","rows","col","Request","_batch","batch","callback","_isBatch","_query","_bulk","table","options","err","_makeBulk","e","charAt","errors","errorHandlers","hasReturned","handleError","doReturn","connection","info","Error","message","stream","emit","event","removeListener","parent","release","handleInfo","msg","number","state","class","lineNumber","serverName","procName","acquire","callbackWithRelease","args","canceled","_cancel","cancel","on","infoMessage","errorMessage","bind","error","done","rowCount","pop","precedingErrors","bulk","newBulkLoad","path","addColumn","create","objectid","temporary","req","replace","execBulkLoad","_setCurrentRequest","execSqlBatch","command","recordsets","recordsetcolumns","output","rowsAffected","recordset","batchLastRow","batchHasOutput","isChunkedRecordset","chunksBuffer","config","row","forEach","i","___return___","doneHandler","more","Object","keys","concatenatedChunks","join","parseJSON","JSON","parse","ex","ex2","defineProperty","enumerable","configurable","fromRecordset","parameterName","exi","Array","parameters","param","validate","collation","declarations","assigns","selects","io","sqlTextOrProcedure","addParameter","addOutputParameter","_execute","procedure","returnValue","enabled","params","map","k","logValue","s","substring","logName","logParams","p","returnStatus","callProcedure","_pause","_currentRequest","pause","_resume","resume","module","exports"],"sources":["C:/Users/phlos/wv-temperature-map/src/backend/node_modules/mssql/lib/tedious/request.js"],"sourcesContent":["'use strict'\n\nconst tds = require('tedious')\nconst debug = require('debug')('mssql:tedi')\nconst BaseRequest = require('../base/request')\nconst RequestError = require('../error/request-error')\nconst { IDS, objectHasProperty } = require('../utils')\nconst { TYPES, DECLARATIONS, declare, cast } = require('../datatypes')\nconst Table = require('../table')\nconst { PARSERS: UDT } = require('../udt')\nconst { valueHandler } = require('../shared')\n\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\n\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n}\n\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar: return tds.TYPES.VarChar\n    case TYPES.NVarChar: return tds.TYPES.NVarChar\n    case TYPES.Text: return tds.TYPES.Text\n    case TYPES.Int: return tds.TYPES.Int\n    case TYPES.BigInt: return tds.TYPES.BigInt\n    case TYPES.TinyInt: return tds.TYPES.TinyInt\n    case TYPES.SmallInt: return tds.TYPES.SmallInt\n    case TYPES.Bit: return tds.TYPES.Bit\n    case TYPES.Float: return tds.TYPES.Float\n    case TYPES.Decimal: return tds.TYPES.Decimal\n    case TYPES.Numeric: return tds.TYPES.Numeric\n    case TYPES.Real: return tds.TYPES.Real\n    case TYPES.Money: return tds.TYPES.Money\n    case TYPES.SmallMoney: return tds.TYPES.SmallMoney\n    case TYPES.Time: return tds.TYPES.Time\n    case TYPES.Date: return tds.TYPES.Date\n    case TYPES.DateTime: return tds.TYPES.DateTime\n    case TYPES.DateTime2: return tds.TYPES.DateTime2\n    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffset\n    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime\n    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifier\n    case TYPES.Xml: return tds.TYPES.NVarChar\n    case TYPES.Char: return tds.TYPES.Char\n    case TYPES.NChar: return tds.TYPES.NChar\n    case TYPES.NText: return tds.TYPES.NVarChar\n    case TYPES.Image: return tds.TYPES.Image\n    case TYPES.Binary: return tds.TYPES.Binary\n    case TYPES.VarBinary: return tds.TYPES.VarBinary\n    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT\n    case TYPES.TVP: return tds.TYPES.TVP\n    case TYPES.Variant: return tds.TYPES.Variant\n    default: return type\n  }\n}\n\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined\n\n  switch (type) {\n    case tds.TYPES.Char: return TYPES.Char\n    case tds.TYPES.NChar: return TYPES.NChar\n    case tds.TYPES.VarChar: return TYPES.VarChar\n    case tds.TYPES.NVarChar: return TYPES.NVarChar\n    case tds.TYPES.Text: return TYPES.Text\n    case tds.TYPES.NText: return TYPES.NText\n    case tds.TYPES.Int: return TYPES.Int\n    case tds.TYPES.BigInt: return TYPES.BigInt\n    case tds.TYPES.TinyInt: return TYPES.TinyInt\n    case tds.TYPES.SmallInt: return TYPES.SmallInt\n    case tds.TYPES.Bit: return TYPES.Bit\n    case tds.TYPES.Float: return TYPES.Float\n    case tds.TYPES.Real: return TYPES.Real\n    case tds.TYPES.Money: return TYPES.Money\n    case tds.TYPES.SmallMoney: return TYPES.SmallMoney\n    case tds.TYPES.Numeric: return TYPES.Numeric\n    case tds.TYPES.Decimal: return TYPES.Decimal\n    case tds.TYPES.DateTime: return TYPES.DateTime\n    case tds.TYPES.Time: return TYPES.Time\n    case tds.TYPES.Date: return TYPES.Date\n    case tds.TYPES.DateTime2: return TYPES.DateTime2\n    case tds.TYPES.DateTimeOffset: return TYPES.DateTimeOffset\n    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime\n    case tds.TYPES.UniqueIdentifier: return TYPES.UniqueIdentifier\n    case tds.TYPES.Image: return TYPES.Image\n    case tds.TYPES.Binary: return TYPES.Binary\n    case tds.TYPES.VarBinary: return TYPES.VarBinary\n    case tds.TYPES.Xml: return TYPES.Xml\n    case tds.TYPES.UDT: return TYPES.UDT\n    case tds.TYPES.TVP: return TYPES.TVP\n    case tds.TYPES.Variant: return TYPES.Variant\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN: return TYPES.Bit\n        case N_TYPES.NumericN: return TYPES.Numeric\n        case N_TYPES.DecimalN: return TYPES.Decimal\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt\n          if (length === 4) return TYPES.Int\n          if (length === 2) return TYPES.SmallInt\n          return TYPES.TinyInt\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float\n          return TYPES.Real\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money\n          return TYPES.SmallMoney\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime\n          return TYPES.SmallDateTime\n      }\n  }\n}\n\nconst createColumns = function (metadata, arrayRowMode) {\n  let out = {}\n  if (arrayRowMode) out = []\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    const column = metadata[index]\n    const outColumn = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    }\n\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      }\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName]\n      }\n    }\n\n    if (arrayRowMode) {\n      out.push(outColumn)\n    } else {\n      out[column.colName] = outColumn\n    }\n  }\n\n  return out\n}\n\nconst valueCorrection = function (value, metadata) {\n  const type = getMssqlType(metadata.type)\n  if (valueHandler.has(type)) {\n    return valueHandler.get(type)(value)\n  } else if ((metadata.type === tds.TYPES.UDT) && (value != null)) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value)\n    } else {\n      return value\n    }\n  } else {\n    return value\n  }\n}\n\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    }\n\n    for (const col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      })\n    }\n\n    return tvp\n  } else {\n    return value\n  }\n}\n\nclass Request extends BaseRequest {\n  /*\n  Execute specified sql batch.\n  */\n\n  _batch (batch, callback) {\n    this._isBatch = true\n    this._query(batch, callback)\n  }\n\n  /*\n  Bulk load.\n  */\n\n  _bulk (table, options, callback) {\n    super._bulk(table, options, err => {\n      if (err) return callback(err)\n\n      try {\n        table._makeBulk()\n      } catch (e) {\n        return callback(new RequestError(e, 'EREQUEST'))\n      }\n\n      if (!table.name) {\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'))\n      }\n\n      if (table.name.charAt(0) === '@') {\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\n      }\n\n      const errors = []\n      const errorHandlers = {}\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        const callbackWithRelease = (err, ...args) => {\n          try {\n            this.parent.release(connection)\n          } catch (e) {\n            // noop\n          }\n          callback(err, ...args)\n        }\n        if (err) return callbackWithRelease(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            hasReturned = true\n\n            if (this.stream) {\n              callbackWithRelease(null, rowCount)\n            } else {\n              callbackWithRelease(error, rowCount)\n            }\n          }\n        }\n\n        const bulk = connection.newBulkLoad(table.path, options, done)\n\n        for (const col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision })\n        }\n\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err)\n\n            connection.execBulkLoad(bulk, table.rows)\n          })\n          this._setCurrentRequest(req)\n\n          connection.execSqlBatch(req)\n        } else {\n          connection.execBulkLoad(bulk, table.rows)\n        }\n      })\n    })\n  }\n\n  /*\n  Execute specified sql command.\n  */\n\n  _query (command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err)\n\n      const recordsets = []\n      const recordsetcolumns = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let batchLastRow = null\n      let batchHasOutput = false\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        let row\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          this.parent.release(connection)\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        debug('request(%d): query', IDS.get(this), command)\n\n        const req = new tds.Request(command, err => {\n          // tedious v15 has started using AggregateErrors to wrap multiple errors into single error objects\n          (err?.errors ? err.errors : [err]).forEach((e, i, { length }) => {\n            // to make sure we handle no-sql errors as well\n            if (e && (!errors.length || (errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message))) {\n              e = new RequestError(e, 'EREQUEST')\n              if (this.stream) this.emit('error', e)\n              errors.push(e)\n            }\n          })\n\n          // process batch outputs\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0]\n\n            for (const name in batchLastRow) {\n              const value = batchLastRow[name]\n              if (name !== '___return___') {\n                output[name] = value\n              }\n            }\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error)\n            } else {\n              debug('request(%d): completed', IDS.get(this))\n            }\n\n            if (this.stream) {\n              callback(null, null, output, rowsAffected, recordsetcolumns)\n            } else {\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns)\n            }\n          }\n        })\n\n        this._setCurrentRequest(req)\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode)\n\n          isChunkedRecordset = false\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns)\n              }\n            } else {\n              this.emit('recordset', columns)\n            }\n          }\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\n        })\n\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount)\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount)\n            }\n          }\n          // this function is called even when select only set variables so we should skip adding a new recordset\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('')\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null\n                } else {\n                  row = JSON.parse(concatenatedChunks)\n                }\n              } catch (ex) {\n                row = null\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = concatenatedChunks\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value (name) { return Table.fromRecordset(this, name) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        }\n\n        req.on('doneInProc', doneHandler) // doneInProc handlers are used in both queries and batches\n        req.on('done', doneHandler) // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          if (this.arrayRowMode) {\n            row = []\n          } else {\n            row = {}\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            if (this.arrayRowMode) {\n              row.push(col.value)\n            } else {\n              const exi = row[col.metadata.colName]\n              if (exi !== undefined) {\n                if (exi instanceof Array) {\n                  exi.push(col.value)\n                } else {\n                  row[col.metadata.colName] = [exi, col.value]\n                }\n              } else {\n                row[col.metadata.colName] = col.value\n              }\n            }\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row\n              } else {\n                this.emit('row', row)\n              }\n            } else {\n              this.emit('row', row)\n            }\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n\n              try {\n                param.value = getTediousType(param.type).validate(param.value, this.parent.collation)\n              } catch (e) {\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`\n                const err = new RequestError(e, 'EPARAM')\n\n                this.parent.release(connection)\n                return callback(err)\n              }\n            }\n\n            const declarations = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              declarations.push(`@${name} ${declare(param.type, param)}`)\n            }\n\n            const assigns = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`)\n            }\n\n            const selects = []\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue\n              }\n              const param = this.parameters[name]\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`)\n              }\n            }\n\n            batchHasOutput = selects.length > 0\n\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`\n          }\n        } else {\n          for (const name in this.parameters) {\n            if (!objectHasProperty(this.parameters, name)) {\n              continue\n            }\n            const param = this.parameters[name]\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n            }\n          }\n        }\n\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req)\n        } catch (error) {\n          handleError(true, connection, error)\n        }\n      })\n    })\n  }\n\n  /*\n  Execute stored procedure with specified parameters.\n  */\n\n  _execute (procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err)\n\n      const recordsets = []\n      const recordsetcolumns = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let returnValue = 0\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err)\n\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\n\n        let row\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this))\n          this.parent.release(connection)\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this))\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        if (debug.enabled) {\n          // log stored procedure executions and provided parameters\n          const params = Object.keys(this.parameters).map(k => this.parameters[k])\n          // cut long string parameters short to keep log somewhat clean\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s\n          // format parameter names as 'my_parameter [sql.Int]'\n          const logName = param => param.name + ' [sql.' + param.type.name + ']'\n          const logParams = {}\n          params.forEach(p => { logParams[logName(p)] = logValue(p.value) })\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams)\n        }\n\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          delete this._cancel\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error)\n            } else {\n              debug('request(%d): complete', IDS.get(this))\n            }\n\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns)\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns)\n            }\n          }\n        })\n\n        this._setCurrentRequest(req)\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode)\n\n          isChunkedRecordset = false\n          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) this.emit('recordset', columns)\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          if (this.arrayRowMode) {\n            row = []\n          } else {\n            row = {}\n          }\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            if (this.arrayRowMode) {\n              row.push(col.value)\n            } else {\n              const exi = row[col.metadata.colName]\n              if (exi != null) {\n                if (exi instanceof Array) {\n                  exi.push(col.value)\n                } else {\n                  row[col.metadata.colName] = [exi, col.value]\n                }\n              } else {\n                row[col.metadata.colName] = col.value\n              }\n            }\n          }\n\n          if (this.stream) {\n            this.emit('row', row)\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount)\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount)\n            }\n          }\n\n          // filter empty recordsets when NOCOUNT is OFF\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''))\n                }\n              } catch (ex) {\n                row = null\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value (name) { return Table.fromRecordset(this, name) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        })\n\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus\n        })\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value\n        })\n\n        for (const name in this.parameters) {\n          if (!objectHasProperty(this.parameters, name)) {\n            continue\n          }\n          const param = this.parameters[name]\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\n          }\n        }\n\n        connection.callProcedure(req)\n      })\n    })\n  }\n\n  _pause () {\n    super._pause()\n    if (this._currentRequest) {\n      this._currentRequest.pause()\n    }\n  }\n\n  _resume () {\n    super._resume()\n    if (this._currentRequest) {\n      this._currentRequest.resume()\n    }\n  }\n}\n\nmodule.exports = Request\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}