{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getRawContent } from \"./file.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./typeGuards.js\";\n/**\n * Drain the content of the given ReadableStream into a Blob.\n * The blob's content may end up in memory or on disk dependent on size.\n */\nfunction drain(stream) {\n  return new Response(stream).blob();\n}\nasync function toBlobPart(source) {\n  if (source instanceof Blob || source instanceof Uint8Array) {\n    return source;\n  }\n  if (isWebReadableStream(source)) {\n    return drain(source);\n  }\n  // If it's not a true Blob, and it's not a Uint8Array, we can assume the source\n  // is a fake File created by createFileFromStream and we can get the original stream\n  // using getRawContent.\n  const rawContent = getRawContent(source);\n  // Shouldn't happen but guard for it anyway\n  if (isNodeReadableStream(rawContent)) {\n    throw new Error(\"Encountered unexpected type. In the browser, `concat` supports Web ReadableStream, Blob, Uint8Array, and files created using `createFile` only.\");\n  }\n  return toBlobPart(rawContent);\n}\n/**\n * Utility function that concatenates a set of binary inputs into one combined output.\n *\n * @param sources - array of sources for the concatenation\n * @returns - in Node, a (() =\\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.\n *           In browser, returns a `Blob` representing all the concatenated inputs.\n *\n * @internal\n */\nexport async function concat(sources) {\n  const parts = [];\n  for (const source of sources) {\n    parts.push(await toBlobPart(typeof source === \"function\" ? source() : source));\n  }\n  return new Blob(parts);\n}","map":{"version":3,"names":["getRawContent","isNodeReadableStream","isWebReadableStream","drain","stream","Response","blob","toBlobPart","source","Blob","Uint8Array","rawContent","Error","concat","sources","parts","push"],"sources":["C:\\Users\\phlos\\wv-temperature-map\\src\\backend\\node_modules\\@azure\\core-rest-pipeline\\src\\util\\concat.common.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { getRawContent } from \"./file.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./typeGuards.js\";\n\n/**\n * Drain the content of the given ReadableStream into a Blob.\n * The blob's content may end up in memory or on disk dependent on size.\n */\nfunction drain(stream: ReadableStream<Uint8Array>): Promise<Blob> {\n  return new Response(stream).blob();\n}\n\nasync function toBlobPart(\n  source: ReadableStream<Uint8Array> | Blob | Uint8Array,\n): Promise<BlobPart> {\n  if (source instanceof Blob || source instanceof Uint8Array) {\n    return source;\n  }\n\n  if (isWebReadableStream(source)) {\n    return drain(source);\n  }\n\n  // If it's not a true Blob, and it's not a Uint8Array, we can assume the source\n  // is a fake File created by createFileFromStream and we can get the original stream\n  // using getRawContent.\n  const rawContent = getRawContent(source);\n\n  // Shouldn't happen but guard for it anyway\n  if (isNodeReadableStream(rawContent)) {\n    throw new Error(\n      \"Encountered unexpected type. In the browser, `concat` supports Web ReadableStream, Blob, Uint8Array, and files created using `createFile` only.\",\n    );\n  }\n\n  return toBlobPart(rawContent);\n}\n\n/**\n * Accepted binary data types for concat\n *\n * @internal\n */\ntype ConcatSource = ReadableStream<Uint8Array> | Blob | Uint8Array;\n\n/**\n * Utility function that concatenates a set of binary inputs into one combined output.\n *\n * @param sources - array of sources for the concatenation\n * @returns - in Node, a (() =\\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.\n *           In browser, returns a `Blob` representing all the concatenated inputs.\n *\n * @internal\n */\nexport async function concat(\n  sources: (ConcatSource | (() => ConcatSource))[],\n): Promise<(() => NodeJS.ReadableStream) | Blob> {\n  const parts = [];\n  for (const source of sources) {\n    parts.push(await toBlobPart(typeof source === \"function\" ? source() : source));\n  }\n\n  return new Blob(parts);\n}\n"],"mappings":"AAAA;AACA;AAEA,SAASA,aAAa,QAAQ,WAAW;AACzC,SAASC,oBAAoB,EAAEC,mBAAmB,QAAQ,iBAAiB;AAE3E;;;;AAIA,SAASC,KAAKA,CAACC,MAAkC;EAC/C,OAAO,IAAIC,QAAQ,CAACD,MAAM,CAAC,CAACE,IAAI,EAAE;AACpC;AAEA,eAAeC,UAAUA,CACvBC,MAAsD;EAEtD,IAAIA,MAAM,YAAYC,IAAI,IAAID,MAAM,YAAYE,UAAU,EAAE;IAC1D,OAAOF,MAAM;EACf;EAEA,IAAIN,mBAAmB,CAACM,MAAM,CAAC,EAAE;IAC/B,OAAOL,KAAK,CAACK,MAAM,CAAC;EACtB;EAEA;EACA;EACA;EACA,MAAMG,UAAU,GAAGX,aAAa,CAACQ,MAAM,CAAC;EAExC;EACA,IAAIP,oBAAoB,CAACU,UAAU,CAAC,EAAE;IACpC,MAAM,IAAIC,KAAK,CACb,iJAAiJ,CAClJ;EACH;EAEA,OAAOL,UAAU,CAACI,UAAU,CAAC;AAC/B;AASA;;;;;;;;;AASA,OAAO,eAAeE,MAAMA,CAC1BC,OAAgD;EAEhD,MAAMC,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMP,MAAM,IAAIM,OAAO,EAAE;IAC5BC,KAAK,CAACC,IAAI,CAAC,MAAMT,UAAU,CAAC,OAAOC,MAAM,KAAK,UAAU,GAAGA,MAAM,EAAE,GAAGA,MAAM,CAAC,CAAC;EAChF;EAEA,OAAO,IAAIC,IAAI,CAACM,KAAK,CAAC;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}